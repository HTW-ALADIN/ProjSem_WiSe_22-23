<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>backend.main API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backend.main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import List, Dict
import sys
from pydantic import BaseModel
import uvicorn
from loguru import logger
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
from fastapi.middleware.cors import CORSMiddleware

from .library.task import Task
from .library.solution import Solution
from .library.laws import ALL as all_laws
from . import generate_tasks as gen
from .generator_strategie import Context, WithDifficultyAndAmount, WithDifficultyAndNeededAndAmount, Default

TASKS: List[Task] = []

origins = [
    &#39;http://localhost:8000&#39;,
    &#39;http://localhost:5173&#39;
]

logger.remove()
logger.add(sys.stdout, colorize=True, format=&#34;&lt;green&gt;{time:HH:mm:ss}&lt;/green&gt; | {level} | &lt;level&gt;{message}&lt;/level&gt;&#34;)


class Row(BaseModel):
    &#34;&#34;&#34;
    Represents a row in the solution table.

    Attributes:
        id (int, optional): The ID of the row. Defaults to 0.
        select (str): The selected value in the row.
        law (str): The law associated with the row.
        num (int): The numerical value associated with the row.

    Methods:
        __str__: Returns a string representation of the row.
    &#34;&#34;&#34;
    id: int = 0
    select: str
    law: str
    num: int

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a string representation of the row.

        Returns:
            str: The string representation of the row.
        &#34;&#34;&#34;
        return f&#34;{self.id} {self.select} {self.law} {self.num}&#34;


def determine_strategie(difficulty, amount, needed, context: Context):
    &#34;&#34;&#34;
    Determine the strategy based on the provided arguments and update the context object with the appropriate strategy.

    Parameters:
        difficulty (int): The difficulty level of the task.
        amount (int): The amount of tasks to generate.
        needed (bool): Whether or not the user specified a specific case to generate tasks for.
        context (Context): The context object to update with the determined strategy.
    &#34;&#34;&#34;
    if difficulty and amount:
        if needed:
            context.strategy = WithDifficultyAndNeededAndAmount() 
        else:
            context.strategy = WithDifficultyAndAmount()


def solutions_with_id(solutions: List[Solution]):
    &#34;&#34;&#34;
    Return a dictionary of solution objects with their case names as the key.

    Parameters:
        solutions (List[Solution]): A list of Solution objects.

    Returns:
        Dict: A dictionary of solution objects with their case names as the key.
    &#34;&#34;&#34;
    sol_and_id = {sol.case_name: sol for sol in solutions}

    return sol_and_id


def search_task(id_of_task):
    &#34;&#34;&#34;
    Return the task object that has the provided ID.

    Parameters:
        id_of_task (int): The ID of the task to search for.

    Returns:
        Task: The task object that has the provided ID. None if no task is found.
    &#34;&#34;&#34;
    wanted_task = None
    for t in TASKS:
        if t.id == id_of_task:
            wanted_task = t
    return wanted_task


def return_json(content: Dict | List | str):
    &#34;&#34;&#34;
    Return a JSON response of the provided content.

    Parameters:
        content(Dict | List | str): The content to return as a JSON response.

    Returns:
        JSONResponse: A JSON response from fastapi of the provided content.
    &#34;&#34;&#34;
    return JSONResponse(jsonable_encoder(content))


def check_row(row: Row, correct: Solution):
    &#34;&#34;&#34;
    Check if the provided row matches the provided correct solution.

    Parameters:
        row (Row): The row object to check.
        correct (Solution): The correct solution object to check against.

    Returns:
        Dict: A dictionary indicating whether or not the row matches the correct solution for each column.
    &#34;&#34;&#34;
    return {
        &#39;name&#39;: correct.case_name == row.select, 
        &#39;law&#39;: correct.law == row.law, 
        &#39;num&#39;: correct.number == row.num
    }


app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_methods=[&#39;*&#39;]
)

def get_correct_solution_value(type: str, solution: Solution):
    if type == &#34;name&#34;:
        return solution.case_name
    elif type == &#34;law&#34;:
        return solution.law
    elif type == &#34;num&#34;:
        return solution.number


app.middleware(&#34;http&#34;)
async def log_request(request: Request):
    logger.debug(f&#34;{request.method} {request.url}&#34;)
    logger.debug(f&#34;Body: {request.body}&#34;)

@app.get(&#34;/get-task/{task_id}&#34;)
def get_certain_task(task_id: int):
    solved_with_solution = {}
    wanted_task = search_task(task_id)
    # get the task and get the solution for the already solved rows
    if not wanted_task:
        raise HTTPException(status_code=404, detail=&#34;Task not found.&#34;)
    
    for case, is_solved in wanted_task.solved.items():
        for type, solved in is_solved.items():
            if solved:
                solved_with_solution[case] = {type: get_correct_solution_value(type, wanted_task.solutions[case])}
            else:
                solved_with_solution[case] = False

    return return_json({&#34;id&#34;: wanted_task.id, &#34;solved&#34;: solved_with_solution, &#34;zve&#34;: wanted_task.zve, &#34;sentences&#34;: [gen.build_sent(case) for case in wanted_task.cases]})

@app.get(&#34;/get-task&#34;)
def get_task(difficulty: int | None = None, amount: int | None = None, needed: str | None = None):
    &#34;&#34;&#34;
    Returns a new task.

    Parameters:
        difficulty (int | None): The difficulty of the task to generate. If None, a random difficulty will be used.
        amount (int | None): The number of cases in the task to generate. If None, a random number of cases will be used.
        needed (str | None): A comma-separated string of case names that must be included in the task. If None, all cases are eligible.

    Returns:
        A JSON response containing the id of the newly created task and a list of sentences describing the cases in the task.
    &#34;&#34;&#34;
    zve = 0
    cases_needed = needed.split(&#39;,&#39;) if needed else []

    context: Context = Context(Default())
    determine_strategie(difficulty, amount, needed, context)

    generated_cases = context.generate_tasks(difficulty, amount, cases_needed)
    solutions = [gen.build_solution(case) for case in generated_cases]
    for solution in solutions:
        print(solution)
        for laws in all_laws:
            gen.map_law(solution, laws)
        zve = zve + solution.number if solution.type_of_case == &#34;Einnahme&#34; else zve - solution.number

    task = Task(cases = generated_cases, solutions=solutions_with_id(solutions), zve=zve)
    TASKS.append(task)

    return return_json({&#34;id&#34;: task.id, &#34;sentences&#34;: [gen.build_sent(case) for case in task.cases]})


@app.get(&#34;/select-options/{id_of_task}&#34;)
def get_select_options(id_of_task: int):
    &#34;&#34;&#34;
    Returns the possible options for each row in a task.

    Args:
        id_of_task (int): The id of the task to get options for.

    Returns:
        A JSON response containing a list of possible options for each row in the task.
    &#34;&#34;&#34;
    wanted_task = search_task(id_of_task)
    if not wanted_task:
        raise HTTPException(status_code=404, detail=&#34;Task not found.&#34;)
    
    return return_json(gen.select_options(wanted_task.cases))


@app.post(&#34;/solve/{id_of_task}&#34;)
def solve(id_of_task: int, user_rows: List[Row]):
    &#34;&#34;&#34;
    Endpoint for checking user solutions to a given task. Checks each row in the user&#39;s submission and compares it to 
    the correct solution for the corresponding case. Returns a dictionary indicating whether each row is correct or not,
    as well as whether all rows have been correctly solved.

    Parameters:
        id_of_task (int): The ID of the task to solve.
        user_rows (List[Row]): A list of user submissions, each represented as a `Row` object.

    Returns:
        A JSON response with a dictionary containing two keys: &#34;given&#34;, which maps the ID of each user submission to a 
        dictionary of three Boolean values indicating whether the user correctly identified the case name, law, and 
        number, and &#34;all_solved&#34;, which is a Boolean indicating whether all rows have been correctly solved.

        Example return value:
        {
            &#34;given&#34;: {
                1: {&#34;name&#34;: True, &#34;law&#34;: True, &#34;num&#34;: False},
                2: {&#34;name&#34;: True, &#34;law&#34;: False, &#34;num&#34;: True},
                3: {&#34;name&#34;: False, &#34;law&#34;: False, &#34;num&#34;: False},
            },
            &#34;all_solved&#34;: False
        }
    &#34;&#34;&#34;
    is_input_correct = {}
    wanted_task = search_task(id_of_task)
    if wanted_task:
        for row in user_rows:
            if row.select in wanted_task.solutions.keys():
                checked = check_row(row, wanted_task.solutions[row.select])
                wanted_task.solved[row.select] = checked
                is_input_correct[row.id] = checked
            else:
                pass
        return return_json({&#39;given&#39;: is_input_correct, &#39;all_solved&#39;: wanted_task.all_solved()})
    # add zve and check if it is also solved
    if not wanted_task:
        raise HTTPException(status_code=404, detail=&#34;Task not found.&#34;)


@app.get(&#34;/solution/{id_of_task}&#34;)
def get_solution(id_of_task: int):
    &#34;&#34;&#34;
    Endpoint for retrieving the correct solutions to a given task. Returns a list of dictionaries, where each dictionary 
    represents a solution to a case in the task. Each dictionary contains the case name, law, number, and type of case.

    Parameters:
        id_of_task (int): The ID of the task to retrieve solutions for.

    Returns:
        A JSON response with a list of dictionaries representing the solutions to each case in the task.

        Example return value:
        [
            {
                &#34;case_name&#34;: &#34;Einkauf&#34;,
                &#34;law&#34;: &#34;BGB § 433&#34;,
                &#34;number&#34;: 1000,
                &#34;type_of_case&#34;: &#34;Ausgabe&#34;
            },
            {
                &#34;case_name&#34;: &#34;Darlehen&#34;,
                &#34;law&#34;: &#34;BGB § 488&#34;,
                &#34;number&#34;: 500,
                &#34;type_of_case&#34;: &#34;Einnahme&#34;
            },
            ...
        ]
    &#34;&#34;&#34;
    wanted_task = search_task(id_of_task)
    if wanted_task:
        return return_json([solution.to_dict() for solution in wanted_task.solutions.values()])
    else:
        raise HTTPException(status_code=404, detail=&#34;Task not found.&#34;)
    


@app.get(&#34;/zve/{id_of_task}&#34;)
def get_zve(id_of_task: int):
    &#34;&#34;&#34;
    Returns the ZVE (zu versteuerndes Einkommen) of the task with the specified ID.

    Parameters:
        id_of_task (int): The ID of the task for which to get the ZVE.

    Returns:
        The ZVE of the task with the specified ID.

    Raises:
        HTTPException: If the task with the specified ID is not found.
    &#34;&#34;&#34;
    wanted_task = search_task(id_of_task)
    if wanted_task:
        return wanted_task.zve
    else:
        raise HTTPException(status_code=404, detail=&#34;Task not found.&#34;)


@app.get(&#34;/cases-to-choose&#34;)
def get_cases_to_choose():
    &#34;&#34;&#34;
    Returns a list of all possible cases that can be chosen in a task.

    Returns:
        A list of all possible cases that can be chosen in a task.
    &#34;&#34;&#34;
    return return_json(list(gen.show_all_cases()))


@app.get(&#34;/generated-tasks&#34;)
def get_tasks_generated():
    &#34;&#34;&#34;
    Returns a dictionary with the IDs of all generated tasks and their status (whether they are solved or not).

    Returns:
        A dictionary with the IDs of all generated tasks and their status (whether they are solved or not).
    &#34;&#34;&#34;
    return return_json({t.id: t.all_solved() for t in TASKS})


if __name__ == &#34;__main__&#34;:
    uvicorn.run(app, host=&#34;0.0.0.0&#34;, log_level=&#34;debug&#34;, port=8000)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="backend.main.check_row"><code class="name flex">
<span>def <span class="ident">check_row</span></span>(<span>row: <a title="backend.main.Row" href="#backend.main.Row">Row</a>, correct: <a title="backend.library.solution.Solution" href="library/solution.html#backend.library.solution.Solution">Solution</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the provided row matches the provided correct solution.</p>
<h2 id="parameters">Parameters</h2>
<p>row (Row): The row object to check.
correct (Solution): The correct solution object to check against.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>A dictionary indicating whether or not the row matches the correct solution for each column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_row(row: Row, correct: Solution):
    &#34;&#34;&#34;
    Check if the provided row matches the provided correct solution.

    Parameters:
        row (Row): The row object to check.
        correct (Solution): The correct solution object to check against.

    Returns:
        Dict: A dictionary indicating whether or not the row matches the correct solution for each column.
    &#34;&#34;&#34;
    return {
        &#39;name&#39;: correct.case_name == row.select, 
        &#39;law&#39;: correct.law == row.law, 
        &#39;num&#39;: correct.number == row.num
    }</code></pre>
</details>
</dd>
<dt id="backend.main.determine_strategie"><code class="name flex">
<span>def <span class="ident">determine_strategie</span></span>(<span>difficulty, amount, needed, context: <a title="backend.generator_strategie.Context" href="generator_strategie.html#backend.generator_strategie.Context">Context</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the strategy based on the provided arguments and update the context object with the appropriate strategy.</p>
<h2 id="parameters">Parameters</h2>
<p>difficulty (int): The difficulty level of the task.
amount (int): The amount of tasks to generate.
needed (bool): Whether or not the user specified a specific case to generate tasks for.
context (Context): The context object to update with the determined strategy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_strategie(difficulty, amount, needed, context: Context):
    &#34;&#34;&#34;
    Determine the strategy based on the provided arguments and update the context object with the appropriate strategy.

    Parameters:
        difficulty (int): The difficulty level of the task.
        amount (int): The amount of tasks to generate.
        needed (bool): Whether or not the user specified a specific case to generate tasks for.
        context (Context): The context object to update with the determined strategy.
    &#34;&#34;&#34;
    if difficulty and amount:
        if needed:
            context.strategy = WithDifficultyAndNeededAndAmount() 
        else:
            context.strategy = WithDifficultyAndAmount()</code></pre>
</details>
</dd>
<dt id="backend.main.get_cases_to_choose"><code class="name flex">
<span>def <span class="ident">get_cases_to_choose</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all possible cases that can be chosen in a task.</p>
<h2 id="returns">Returns</h2>
<p>A list of all possible cases that can be chosen in a task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/cases-to-choose&#34;)
def get_cases_to_choose():
    &#34;&#34;&#34;
    Returns a list of all possible cases that can be chosen in a task.

    Returns:
        A list of all possible cases that can be chosen in a task.
    &#34;&#34;&#34;
    return return_json(list(gen.show_all_cases()))</code></pre>
</details>
</dd>
<dt id="backend.main.get_certain_task"><code class="name flex">
<span>def <span class="ident">get_certain_task</span></span>(<span>task_id: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/get-task/{task_id}&#34;)
def get_certain_task(task_id: int):
    solved_with_solution = {}
    wanted_task = search_task(task_id)
    # get the task and get the solution for the already solved rows
    if not wanted_task:
        raise HTTPException(status_code=404, detail=&#34;Task not found.&#34;)
    
    for case, is_solved in wanted_task.solved.items():
        for type, solved in is_solved.items():
            if solved:
                solved_with_solution[case] = {type: get_correct_solution_value(type, wanted_task.solutions[case])}
            else:
                solved_with_solution[case] = False

    return return_json({&#34;id&#34;: wanted_task.id, &#34;solved&#34;: solved_with_solution, &#34;zve&#34;: wanted_task.zve, &#34;sentences&#34;: [gen.build_sent(case) for case in wanted_task.cases]})</code></pre>
</details>
</dd>
<dt id="backend.main.get_correct_solution_value"><code class="name flex">
<span>def <span class="ident">get_correct_solution_value</span></span>(<span>type: str, solution: <a title="backend.library.solution.Solution" href="library/solution.html#backend.library.solution.Solution">Solution</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_correct_solution_value(type: str, solution: Solution):
    if type == &#34;name&#34;:
        return solution.case_name
    elif type == &#34;law&#34;:
        return solution.law
    elif type == &#34;num&#34;:
        return solution.number</code></pre>
</details>
</dd>
<dt id="backend.main.get_select_options"><code class="name flex">
<span>def <span class="ident">get_select_options</span></span>(<span>id_of_task: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the possible options for each row in a task.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id_of_task</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the task to get options for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A JSON response containing a list of possible options for each row in the task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/select-options/{id_of_task}&#34;)
def get_select_options(id_of_task: int):
    &#34;&#34;&#34;
    Returns the possible options for each row in a task.

    Args:
        id_of_task (int): The id of the task to get options for.

    Returns:
        A JSON response containing a list of possible options for each row in the task.
    &#34;&#34;&#34;
    wanted_task = search_task(id_of_task)
    if not wanted_task:
        raise HTTPException(status_code=404, detail=&#34;Task not found.&#34;)
    
    return return_json(gen.select_options(wanted_task.cases))</code></pre>
</details>
</dd>
<dt id="backend.main.get_solution"><code class="name flex">
<span>def <span class="ident">get_solution</span></span>(<span>id_of_task: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Endpoint for retrieving the correct solutions to a given task. Returns a list of dictionaries, where each dictionary
represents a solution to a case in the task. Each dictionary contains the case name, law, number, and type of case.</p>
<h2 id="parameters">Parameters</h2>
<p>id_of_task (int): The ID of the task to retrieve solutions for.</p>
<h2 id="returns">Returns</h2>
<p>A JSON response with a list of dictionaries representing the solutions to each case in the task.</p>
<p>Example return value:
[
{
"case_name": "Einkauf",
"law": "BGB § 433",
"number": 1000,
"type_of_case": "Ausgabe"
},
{
"case_name": "Darlehen",
"law": "BGB § 488",
"number": 500,
"type_of_case": "Einnahme"
},
&hellip;
]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/solution/{id_of_task}&#34;)
def get_solution(id_of_task: int):
    &#34;&#34;&#34;
    Endpoint for retrieving the correct solutions to a given task. Returns a list of dictionaries, where each dictionary 
    represents a solution to a case in the task. Each dictionary contains the case name, law, number, and type of case.

    Parameters:
        id_of_task (int): The ID of the task to retrieve solutions for.

    Returns:
        A JSON response with a list of dictionaries representing the solutions to each case in the task.

        Example return value:
        [
            {
                &#34;case_name&#34;: &#34;Einkauf&#34;,
                &#34;law&#34;: &#34;BGB § 433&#34;,
                &#34;number&#34;: 1000,
                &#34;type_of_case&#34;: &#34;Ausgabe&#34;
            },
            {
                &#34;case_name&#34;: &#34;Darlehen&#34;,
                &#34;law&#34;: &#34;BGB § 488&#34;,
                &#34;number&#34;: 500,
                &#34;type_of_case&#34;: &#34;Einnahme&#34;
            },
            ...
        ]
    &#34;&#34;&#34;
    wanted_task = search_task(id_of_task)
    if wanted_task:
        return return_json([solution.to_dict() for solution in wanted_task.solutions.values()])
    else:
        raise HTTPException(status_code=404, detail=&#34;Task not found.&#34;)</code></pre>
</details>
</dd>
<dt id="backend.main.get_task"><code class="name flex">
<span>def <span class="ident">get_task</span></span>(<span>difficulty: int | None = None, amount: int | None = None, needed: str | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new task.</p>
<h2 id="parameters">Parameters</h2>
<p>difficulty (int | None): The difficulty of the task to generate. If None, a random difficulty will be used.
amount (int | None): The number of cases in the task to generate. If None, a random number of cases will be used.
needed (str | None): A comma-separated string of case names that must be included in the task. If None, all cases are eligible.</p>
<h2 id="returns">Returns</h2>
<p>A JSON response containing the id of the newly created task and a list of sentences describing the cases in the task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/get-task&#34;)
def get_task(difficulty: int | None = None, amount: int | None = None, needed: str | None = None):
    &#34;&#34;&#34;
    Returns a new task.

    Parameters:
        difficulty (int | None): The difficulty of the task to generate. If None, a random difficulty will be used.
        amount (int | None): The number of cases in the task to generate. If None, a random number of cases will be used.
        needed (str | None): A comma-separated string of case names that must be included in the task. If None, all cases are eligible.

    Returns:
        A JSON response containing the id of the newly created task and a list of sentences describing the cases in the task.
    &#34;&#34;&#34;
    zve = 0
    cases_needed = needed.split(&#39;,&#39;) if needed else []

    context: Context = Context(Default())
    determine_strategie(difficulty, amount, needed, context)

    generated_cases = context.generate_tasks(difficulty, amount, cases_needed)
    solutions = [gen.build_solution(case) for case in generated_cases]
    for solution in solutions:
        print(solution)
        for laws in all_laws:
            gen.map_law(solution, laws)
        zve = zve + solution.number if solution.type_of_case == &#34;Einnahme&#34; else zve - solution.number

    task = Task(cases = generated_cases, solutions=solutions_with_id(solutions), zve=zve)
    TASKS.append(task)

    return return_json({&#34;id&#34;: task.id, &#34;sentences&#34;: [gen.build_sent(case) for case in task.cases]})</code></pre>
</details>
</dd>
<dt id="backend.main.get_tasks_generated"><code class="name flex">
<span>def <span class="ident">get_tasks_generated</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary with the IDs of all generated tasks and their status (whether they are solved or not).</p>
<h2 id="returns">Returns</h2>
<p>A dictionary with the IDs of all generated tasks and their status (whether they are solved or not).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/generated-tasks&#34;)
def get_tasks_generated():
    &#34;&#34;&#34;
    Returns a dictionary with the IDs of all generated tasks and their status (whether they are solved or not).

    Returns:
        A dictionary with the IDs of all generated tasks and their status (whether they are solved or not).
    &#34;&#34;&#34;
    return return_json({t.id: t.all_solved() for t in TASKS})</code></pre>
</details>
</dd>
<dt id="backend.main.get_zve"><code class="name flex">
<span>def <span class="ident">get_zve</span></span>(<span>id_of_task: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the ZVE (zu versteuerndes Einkommen) of the task with the specified ID.</p>
<h2 id="parameters">Parameters</h2>
<p>id_of_task (int): The ID of the task for which to get the ZVE.</p>
<h2 id="returns">Returns</h2>
<p>The ZVE of the task with the specified ID.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>HTTPException</code></dt>
<dd>If the task with the specified ID is not found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.get(&#34;/zve/{id_of_task}&#34;)
def get_zve(id_of_task: int):
    &#34;&#34;&#34;
    Returns the ZVE (zu versteuerndes Einkommen) of the task with the specified ID.

    Parameters:
        id_of_task (int): The ID of the task for which to get the ZVE.

    Returns:
        The ZVE of the task with the specified ID.

    Raises:
        HTTPException: If the task with the specified ID is not found.
    &#34;&#34;&#34;
    wanted_task = search_task(id_of_task)
    if wanted_task:
        return wanted_task.zve
    else:
        raise HTTPException(status_code=404, detail=&#34;Task not found.&#34;)</code></pre>
</details>
</dd>
<dt id="backend.main.log_request"><code class="name flex">
<span>async def <span class="ident">log_request</span></span>(<span>request: starlette.requests.Request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def log_request(request: Request):
    logger.debug(f&#34;{request.method} {request.url}&#34;)
    logger.debug(f&#34;Body: {request.body}&#34;)</code></pre>
</details>
</dd>
<dt id="backend.main.return_json"><code class="name flex">
<span>def <span class="ident">return_json</span></span>(<span>content: Union[Dict, List, str])</span>
</code></dt>
<dd>
<div class="desc"><p>Return a JSON response of the provided content.</p>
<h2 id="parameters">Parameters</h2>
<p>content(Dict | List | str): The content to return as a JSON response.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JSONResponse</code></dt>
<dd>A JSON response from fastapi of the provided content.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_json(content: Dict | List | str):
    &#34;&#34;&#34;
    Return a JSON response of the provided content.

    Parameters:
        content(Dict | List | str): The content to return as a JSON response.

    Returns:
        JSONResponse: A JSON response from fastapi of the provided content.
    &#34;&#34;&#34;
    return JSONResponse(jsonable_encoder(content))</code></pre>
</details>
</dd>
<dt id="backend.main.search_task"><code class="name flex">
<span>def <span class="ident">search_task</span></span>(<span>id_of_task)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the task object that has the provided ID.</p>
<h2 id="parameters">Parameters</h2>
<p>id_of_task (int): The ID of the task to search for.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Task</code></dt>
<dd>The task object that has the provided ID. None if no task is found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_task(id_of_task):
    &#34;&#34;&#34;
    Return the task object that has the provided ID.

    Parameters:
        id_of_task (int): The ID of the task to search for.

    Returns:
        Task: The task object that has the provided ID. None if no task is found.
    &#34;&#34;&#34;
    wanted_task = None
    for t in TASKS:
        if t.id == id_of_task:
            wanted_task = t
    return wanted_task</code></pre>
</details>
</dd>
<dt id="backend.main.solutions_with_id"><code class="name flex">
<span>def <span class="ident">solutions_with_id</span></span>(<span>solutions: List[<a title="backend.library.solution.Solution" href="library/solution.html#backend.library.solution.Solution">Solution</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary of solution objects with their case names as the key.</p>
<h2 id="parameters">Parameters</h2>
<p>solutions (List[Solution]): A list of Solution objects.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>A dictionary of solution objects with their case names as the key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solutions_with_id(solutions: List[Solution]):
    &#34;&#34;&#34;
    Return a dictionary of solution objects with their case names as the key.

    Parameters:
        solutions (List[Solution]): A list of Solution objects.

    Returns:
        Dict: A dictionary of solution objects with their case names as the key.
    &#34;&#34;&#34;
    sol_and_id = {sol.case_name: sol for sol in solutions}

    return sol_and_id</code></pre>
</details>
</dd>
<dt id="backend.main.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>id_of_task: int, user_rows: List[<a title="backend.main.Row" href="#backend.main.Row">Row</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Endpoint for checking user solutions to a given task. Checks each row in the user's submission and compares it to
the correct solution for the corresponding case. Returns a dictionary indicating whether each row is correct or not,
as well as whether all rows have been correctly solved.</p>
<h2 id="parameters">Parameters</h2>
<p>id_of_task (int): The ID of the task to solve.
user_rows (List[Row]): A list of user submissions, each represented as a <code><a title="backend.main.Row" href="#backend.main.Row">Row</a></code> object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A JSON response with a dictionary containing two keys</code></dt>
<dd>"given", which maps the ID of each user submission to a </dd>
</dl>
<p>dictionary of three Boolean values indicating whether the user correctly identified the case name, law, and
number, and "all_solved", which is a Boolean indicating whether all rows have been correctly solved.</p>
<dl>
<dt>Example return value:</dt>
<dt>{</dt>
<dt>"given": {</dt>
<dt><code>
1</code></dt>
<dd>{"name": True, "law": True, "num": False},
2: {"name": True, "law": False, "num": True},
3: {"name": False, "law": False, "num": False},
},
"all_solved": False</dd>
</dl>
<p>}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.post(&#34;/solve/{id_of_task}&#34;)
def solve(id_of_task: int, user_rows: List[Row]):
    &#34;&#34;&#34;
    Endpoint for checking user solutions to a given task. Checks each row in the user&#39;s submission and compares it to 
    the correct solution for the corresponding case. Returns a dictionary indicating whether each row is correct or not,
    as well as whether all rows have been correctly solved.

    Parameters:
        id_of_task (int): The ID of the task to solve.
        user_rows (List[Row]): A list of user submissions, each represented as a `Row` object.

    Returns:
        A JSON response with a dictionary containing two keys: &#34;given&#34;, which maps the ID of each user submission to a 
        dictionary of three Boolean values indicating whether the user correctly identified the case name, law, and 
        number, and &#34;all_solved&#34;, which is a Boolean indicating whether all rows have been correctly solved.

        Example return value:
        {
            &#34;given&#34;: {
                1: {&#34;name&#34;: True, &#34;law&#34;: True, &#34;num&#34;: False},
                2: {&#34;name&#34;: True, &#34;law&#34;: False, &#34;num&#34;: True},
                3: {&#34;name&#34;: False, &#34;law&#34;: False, &#34;num&#34;: False},
            },
            &#34;all_solved&#34;: False
        }
    &#34;&#34;&#34;
    is_input_correct = {}
    wanted_task = search_task(id_of_task)
    if wanted_task:
        for row in user_rows:
            if row.select in wanted_task.solutions.keys():
                checked = check_row(row, wanted_task.solutions[row.select])
                wanted_task.solved[row.select] = checked
                is_input_correct[row.id] = checked
            else:
                pass
        return return_json({&#39;given&#39;: is_input_correct, &#39;all_solved&#39;: wanted_task.all_solved()})
    # add zve and check if it is also solved
    if not wanted_task:
        raise HTTPException(status_code=404, detail=&#34;Task not found.&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backend.main.Row"><code class="flex name class">
<span>class <span class="ident">Row</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a row in the solution table.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The ID of the row. Defaults to 0.</dd>
<dt><strong><code>select</code></strong> :&ensp;<code>str</code></dt>
<dd>The selected value in the row.</dd>
<dt><strong><code>law</code></strong> :&ensp;<code>str</code></dt>
<dd>The law associated with the row.</dd>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code></dt>
<dd>The numerical value associated with the row.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p><strong>str</strong>: Returns a string representation of the row.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Row(BaseModel):
    &#34;&#34;&#34;
    Represents a row in the solution table.

    Attributes:
        id (int, optional): The ID of the row. Defaults to 0.
        select (str): The selected value in the row.
        law (str): The law associated with the row.
        num (int): The numerical value associated with the row.

    Methods:
        __str__: Returns a string representation of the row.
    &#34;&#34;&#34;
    id: int = 0
    select: str
    law: str
    num: int

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a string representation of the row.

        Returns:
            str: The string representation of the row.
        &#34;&#34;&#34;
        return f&#34;{self.id} {self.select} {self.law} {self.num}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backend.main.Row.id"><code class="name">var <span class="ident">id</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backend.main.Row.law"><code class="name">var <span class="ident">law</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backend.main.Row.num"><code class="name">var <span class="ident">num</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backend.main.Row.select"><code class="name">var <span class="ident">select</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backend" href="index.html">backend</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="backend.main.check_row" href="#backend.main.check_row">check_row</a></code></li>
<li><code><a title="backend.main.determine_strategie" href="#backend.main.determine_strategie">determine_strategie</a></code></li>
<li><code><a title="backend.main.get_cases_to_choose" href="#backend.main.get_cases_to_choose">get_cases_to_choose</a></code></li>
<li><code><a title="backend.main.get_certain_task" href="#backend.main.get_certain_task">get_certain_task</a></code></li>
<li><code><a title="backend.main.get_correct_solution_value" href="#backend.main.get_correct_solution_value">get_correct_solution_value</a></code></li>
<li><code><a title="backend.main.get_select_options" href="#backend.main.get_select_options">get_select_options</a></code></li>
<li><code><a title="backend.main.get_solution" href="#backend.main.get_solution">get_solution</a></code></li>
<li><code><a title="backend.main.get_task" href="#backend.main.get_task">get_task</a></code></li>
<li><code><a title="backend.main.get_tasks_generated" href="#backend.main.get_tasks_generated">get_tasks_generated</a></code></li>
<li><code><a title="backend.main.get_zve" href="#backend.main.get_zve">get_zve</a></code></li>
<li><code><a title="backend.main.log_request" href="#backend.main.log_request">log_request</a></code></li>
<li><code><a title="backend.main.return_json" href="#backend.main.return_json">return_json</a></code></li>
<li><code><a title="backend.main.search_task" href="#backend.main.search_task">search_task</a></code></li>
<li><code><a title="backend.main.solutions_with_id" href="#backend.main.solutions_with_id">solutions_with_id</a></code></li>
<li><code><a title="backend.main.solve" href="#backend.main.solve">solve</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backend.main.Row" href="#backend.main.Row">Row</a></code></h4>
<ul class="">
<li><code><a title="backend.main.Row.id" href="#backend.main.Row.id">id</a></code></li>
<li><code><a title="backend.main.Row.law" href="#backend.main.Row.law">law</a></code></li>
<li><code><a title="backend.main.Row.num" href="#backend.main.Row.num">num</a></code></li>
<li><code><a title="backend.main.Row.select" href="#backend.main.Row.select">select</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>